/*
Copyright 2019 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"sigs.k8s.io/yaml"
	"strconv"
	"strings"

	prowConfig "k8s.io/test-infra/prow/config"
	testgridConfig "k8s.io/test-infra/testgrid/config"
)

const (
	testgridCreateTestGroupAnnotation        = "testgrid-create-test-group"
	testgridDashboardsAnnotation             = "testgrid-dashboards"
	testgridTabNameAnnotation                = "testgrid-tab-name"
	testgridEmailAnnotation                  = "testgrid-alert-email"
	testgridNumColumnsRecentAnnotation       = "testgrid-num-columns-recent"
	testgridAlertStaleResultsHoursAnnotation = "testgrid-alert-stale-results-hours"
	testgridNumFailuresToAlertAnnotation     = "testgrid-num-failures-to-alert"
	descriptionAnnotation                    = "description"
)

const commentHeader = `# Automatically Generated by Footnote; DO NOT EDIT
# Generated from %s
`

type options struct {
	prowJobConfig   string
	output          string
	defaultConfig   string
	gcsPrefixPrefix string
}

func gatherOptions() (options, error) {
	o := options{}
	flag.StringVar(&o.prowJobConfig, "prow-job-config", "", "Path to the prow job config.")
	flag.StringVar(&o.output, "output", "output-config.yaml", "Write configuration to /local/path/file.yaml")
	flag.StringVar(&o.defaultConfig, "default-config", "default-template.yaml", "Path to a Testgrid YAML with default settings to copy")
	flag.StringVar(&o.gcsPrefixPrefix, "gcs-bucket", "", "Generated GCS prefixes will be <gcs-bucket>/<ProwJobName>")
	flag.Parse()

	// Verification
	if o.prowJobConfig == "" {
		return o, errors.New("--prow-job-config must be specified")
	}
	if !strings.HasSuffix(o.defaultConfig, ".yaml") {
		return o, errors.New("--default-config must point to a single YAML file")
	}
	if o.gcsPrefixPrefix == "" {
		return o, errors.New("--gcs-bucket shouldn't be nothing")
	}

	// Coercion
	if !strings.HasSuffix(o.gcsPrefixPrefix, "/") {
		o.gcsPrefixPrefix += "/"
	}

	return o, nil
}

func main() {
	// Parse flags
	opt, err := gatherOptions()
	if err != nil {
		log.Fatalf("Bad flags: %v", err)
	}

	// Fill in the Default Object
	defaultConfig, err := getDefaultConfiguration(opt.defaultConfig)
	if err != nil {
		log.Fatalf("Can't read default config: %v", err)
	}

	// Import the prow jobs
	jobs, err := prowConfig.ReadJobConfig(opt.prowJobConfig)
	if err != nil {
		log.Fatalf("Can't Read Prow Jobs: %v", err)
	}

	// Fill in the Configuration Object
	tgConfig, err := getConfiguration(jobs, opt)
	if err != nil {
		log.Fatalf("Error: %v", err)
	}

	// Serialize into output
	dOut, err := yaml.Marshal(defaultConfig)
	if err != nil {
		log.Fatalf("Couldn't marshal default configuration %v", defaultConfig)
	}

	tgOut, err := yaml.Marshal(tgConfig)
	if err != nil {
		log.Fatalf("Couldn't marshal configuration %v", tgOut)
	}

	fp, err := os.Create(opt.output)
	if err != nil {
		log.Fatalf("Couldn't create file at %s", opt.output)
	}
	defer fp.Close()

	fp.WriteString(fmt.Sprintf(commentHeader, opt.prowJobConfig))
	fp.WriteString("\n")

	fp.Write(dOut)
	fp.WriteString("\n")

	fp.Write(tgOut)
}

func tokenize(csv string) []string {
	tokens := strings.Split(csv, ",")
	for i := range tokens {
		tokens[i] = strings.TrimSpace(tokens[i])
	}
	return tokens
}

func getDefaultConfiguration(path string) (*testgridConfig.DefaultConfiguration, error) {
	//Deserialize the default object located at "path"
	config := &testgridConfig.DefaultConfiguration{}

	file, err := ioutil.ReadFile(path)
	if err != nil {
		return config, err
	}

	err = yaml.Unmarshal(file, config)
	return config, err
}

func getConfiguration(pjs prowConfig.JobConfig, opt options) (*testgridConfig.Configuration, error) {
	// Fill in the YAML object with the prow job annotations
	var tgConfig testgridConfig.Configuration

	// Dashboards are kept in a map to handle when two tabs want to be on the same dashboard
	dashMap := make(map[string][]*testgridConfig.DashboardTab)

	for pjname, annotation := range allAnnotatedJobs(pjs) {
		// Required Testgrid Annotations
		testGroupForce := annotation[testgridCreateTestGroupAnnotation]
		dashboardListing := annotation[testgridDashboardsAnnotation]

		if testGroupForce == "" && dashboardListing == "" {
			continue
		}

		// Add Test Group
		num_columns_recent, _ := strconv.Atoi(annotation[testgridNumColumnsRecentAnnotation])
		alert_stale, _ := strconv.Atoi(annotation[testgridAlertStaleResultsHoursAnnotation])
		num_failures, _ := strconv.Atoi(annotation[testgridNumFailuresToAlertAnnotation])

		if testGroupForce != "false" {
			testgroup := testgridConfig.TestGroup{
				Name:                   pjname,
				GcsPrefix:              opt.gcsPrefixPrefix + pjname,
				NumColumnsRecent:       int32(num_columns_recent),
				AlertStaleResultsHours: int32(alert_stale),
				NumFailuresToAlert:     int32(num_failures),
			}
			tgConfig.TestGroups = append(tgConfig.TestGroups, &testgroup)
		}

		// Add Dashboards
		dashboards := tokenize(dashboardListing)
		for i, dashboardName := range dashboards {
			dashtab := testgridConfig.DashboardTab{
				Name:          annotation[testgridTabNameAnnotation],
				Description:   annotation[descriptionAnnotation],
				TestGroupName: pjname,
			}

			// Alert emails only go on the first dashboard specified
			if i == 1 {
				dashtab.AlertOptions = &testgridConfig.DashboardTabAlertOptions{
					AlertMailToAddresses: annotation[testgridEmailAnnotation],
				}
			}

			dashMap[dashboardName] = append(dashMap[dashboardName], &dashtab)
		}
	}

	for dashboardName, dashboardTabs := range dashMap {
		newdash := testgridConfig.Dashboard{
			Name:         dashboardName,
			DashboardTab: dashboardTabs,
		}
		tgConfig.Dashboards = append(tgConfig.Dashboards, &newdash)
	}

	return &tgConfig, nil
}

// map[string]map[string]string == map[ProwJobName]Annotations
// This function also guarantees that Prow Job Names are unique, by picking one arbitrarily
func allAnnotatedJobs(jobs prowConfig.JobConfig) map[string]map[string]string {

	an := make(map[string]map[string]string)

	for _, job := range jobs.AllPeriodics() {
		if len(job.Annotations) != 0 {
			an[job.Name] = job.Annotations
		}
	}

	for _, job := range jobs.AllPresubmits(make([]string, 0)) {
		if len(job.Annotations) != 0 {
			an[job.Name] = job.Annotations
		}
	}

	for _, job := range jobs.AllPostsubmits(make([]string, 0)) {
		if len(job.Annotations) != 0 {
			an[job.Name] = job.Annotations
		}
	}

	return an
}
