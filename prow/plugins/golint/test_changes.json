[
  {
    "sha": "bf6269d3ced68c78febcdd856e9a05473f5738be",
    "filename": "cmd/libs/go2idl/client-gen/generators/BUILD",
    "status": "modified",
    "additions": 2,
    "deletions": 0,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/BUILD",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/BUILD",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/BUILD?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -22,6 +22,7 @@ go_library(\n         \"//cmd/libs/go2idl/client-gen/args:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/generators/fake:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/generators/scheme:go_default_library\",\n+        \"//cmd/libs/go2idl/client-gen/generators/util:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/path:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/types:go_default_library\",\n         \"//vendor/github.com/golang/glog:go_default_library\",\n@@ -45,6 +46,7 @@ filegroup(\n         \":package-srcs\",\n         \"//cmd/libs/go2idl/client-gen/generators/fake:all-srcs\",\n         \"//cmd/libs/go2idl/client-gen/generators/scheme:all-srcs\",\n+        \"//cmd/libs/go2idl/client-gen/generators/util:all-srcs\",\n     ],\n     tags = [\"automanaged\"],\n )"
  },
  {
    "sha": "8553d5113b91cd75fc1fbb5d29de1c837f48ba4c",
    "filename": "cmd/libs/go2idl/client-gen/generators/client_generator.go",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/client_generator.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/client_generator.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/client_generator.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -29,6 +29,7 @@ import (\n \tclientgenargs \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/args\"\n \t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/fake\"\n \t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/scheme\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n \t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/path\"\n \tclientgentypes \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types\"\n \n@@ -124,7 +125,7 @@ func packageForGroup(gv clientgentypes.GroupVersion, typeList []*types.Type, cli\n \t\t\treturn generators\n \t\t},\n \t\tFilterFunc: func(c *generator.Context, t *types.Type) bool {\n-\t\t\treturn extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == true\n+\t\t\treturn util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient\n \t\t},\n \t}\n }\n@@ -297,7 +298,7 @@ func Packages(context *generator.Context, arguments *args.GeneratorArgs) generat\n \t\t\t} else {\n \t\t\t\t// User has not specified any override for this group version.\n \t\t\t\t// filter out types which dont have genclient=true.\n-\t\t\t\tif extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == false {\n+\t\t\t\tif tags := util.MustParseClientGenTags(t.SecondClosestCommentLines); !tags.GenerateClient {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t}"
  },
  {
    "sha": "985bec6e4ef6ad1cbea4e26841352062d716532e",
    "filename": "cmd/libs/go2idl/client-gen/generators/fake/BUILD",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/BUILD",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/BUILD",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/fake/BUILD?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -19,9 +19,9 @@ go_library(\n     deps = [\n         \"//cmd/libs/go2idl/client-gen/args:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/generators/scheme:go_default_library\",\n+        \"//cmd/libs/go2idl/client-gen/generators/util:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/path:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/types:go_default_library\",\n-        \"//vendor/github.com/golang/glog:go_default_library\",\n         \"//vendor/k8s.io/gengo/generator:go_default_library\",\n         \"//vendor/k8s.io/gengo/namer:go_default_library\",\n         \"//vendor/k8s.io/gengo/types:go_default_library\","
  },
  {
    "sha": "c8addaf9b08da9666ab16270eecfc52ae969c96c",
    "filename": "cmd/libs/go2idl/client-gen/generators/fake/fake_client_generator.go",
    "status": "modified",
    "additions": 2,
    "deletions": 11,
    "changes": 13,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/fake_client_generator.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/fake_client_generator.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/fake/fake_client_generator.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -20,12 +20,11 @@ import (\n \t\"path/filepath\"\n \t\"strings\"\n \n-\t\"github.com/golang/glog\"\n-\n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/types\"\n \tclientgenargs \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/args\"\n \tscheme \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/scheme\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n \tclientgentypes \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types\"\n )\n \n@@ -78,19 +77,11 @@ func PackageForGroup(gv clientgentypes.GroupVersion, typeList []*types.Type, cli\n \t\t\treturn generators\n \t\t},\n \t\tFilterFunc: func(c *generator.Context, t *types.Type) bool {\n-\t\t\treturn extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == true\n+\t\t\treturn util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient\n \t\t},\n \t}\n }\n \n-func extractBoolTagOrDie(key string, lines []string) bool {\n-\tval, err := types.ExtractSingleBoolCommentTag(\"+\", key, false, lines)\n-\tif err != nil {\n-\t\tglog.Fatalf(err.Error())\n-\t}\n-\treturn val\n-}\n-\n func PackageForClientset(customArgs clientgenargs.Args, fakeClientsetPackage string, boilerplate []byte, generatedBy string) generator.Package {\n \treturn &generator.DefaultPackage{\n \t\t// TODO: we'll generate fake clientset for different release in the future."
  },
  {
    "sha": "5493aa105d5a22eb1950172a8897dea38bca6e81",
    "filename": "cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_group.go",
    "status": "modified",
    "additions": 8,
    "deletions": 5,
    "changes": 13,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_group.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_group.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_group.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -25,6 +25,7 @@ import (\n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/namer\"\n \t\"k8s.io/gengo/types\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n )\n \n // genFakeForGroup produces a file for a group client, e.g. ExtensionsClient for the extension group.\n@@ -70,18 +71,20 @@ func (g *genFakeForGroup) GenerateType(c *generator.Context, t *types.Type, w io\n \n \tsw.Do(groupClientTemplate, m)\n \tfor _, t := range g.types {\n+\t\ttags, err := util.ParseClientGenTags(t.SecondClosestCommentLines)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\twrapper := map[string]interface{}{\n \t\t\t\"type\":              t,\n \t\t\t\"GroupVersion\":      namer.IC(g.group) + namer.IC(g.version),\n \t\t\t\"realClientPackage\": strings.ToLower(filepath.Base(g.realClientPackage)),\n \t\t}\n-\t\tnamespaced := !extractBoolTagOrDie(\"nonNamespaced\", t.SecondClosestCommentLines)\n-\t\tif namespaced {\n-\t\t\tsw.Do(getterImplNamespaced, wrapper)\n-\t\t} else {\n+\t\tif tags.NonNamespaced {\n \t\t\tsw.Do(getterImplNonNamespaced, wrapper)\n-\n+\t\t\tcontinue\n \t\t}\n+\t\tsw.Do(getterImplNamespaced, wrapper)\n \t}\n \tsw.Do(getRESTClient, m)\n \treturn sw.Error()"
  },
  {
    "sha": "f1f306576f4641e2046f531b07260a36ba12a711",
    "filename": "cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_type.go",
    "status": "modified",
    "additions": 41,
    "deletions": 32,
    "changes": 73,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_type.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_type.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/fake/generator_fake_for_type.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -17,13 +17,14 @@ limitations under the License.\n package fake\n \n import (\n-\t\"fmt\"\n \t\"io\"\n \t\"path/filepath\"\n \n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/namer\"\n \t\"k8s.io/gengo/types\"\n+\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n \t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/path\"\n )\n \n@@ -66,12 +67,8 @@ func genStatus(t *types.Type) bool {\n \t\t}\n \t}\n \n-\t// Allow overriding via a comment on the type\n-\tgenStatus, err := types.ExtractSingleBoolCommentTag(\"+\", \"genclientstatus\", hasStatus, t.SecondClosestCommentLines)\n-\tif err != nil {\n-\t\tfmt.Printf(\"error looking up +genclientstatus: %v\\n\", err)\n-\t}\n-\treturn genStatus\n+\ttags := util.MustParseClientGenTags(t.SecondClosestCommentLines)\n+\treturn hasStatus && !tags.NoStatus\n }\n \n // hasObjectMeta returns true if the type has a ObjectMeta field.\n@@ -88,7 +85,10 @@ func hasObjectMeta(t *types.Type) bool {\n func (g *genFakeForType) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {\n \tsw := generator.NewSnippetWriter(w, c, \"$\", \"$\")\n \tpkg := filepath.Base(t.Name.Package)\n-\tnamespaced := !extractBoolTagOrDie(\"nonNamespaced\", t.SecondClosestCommentLines)\n+\ttags, err := util.ParseClientGenTags(t.SecondClosestCommentLines)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tcanonicalGroup := g.group\n \tif canonicalGroup == \"core\" {\n \t\tcanonicalGroup = \"\"\n@@ -110,7 +110,7 @@ func (g *genFakeForType) GenerateType(c *generator.Context, t *types.Type, w io.\n \t\t\"type\":                 t,\n \t\t\"package\":              pkg,\n \t\t\"Package\":              namer.IC(pkg),\n-\t\t\"namespaced\":           namespaced,\n+\t\t\"namespaced\":           !tags.NonNamespaced,\n \t\t\"Group\":                namer.IC(g.group),\n \t\t\"GroupVersion\":         namer.IC(g.group) + namer.IC(g.version),\n \t\t\"group\":                canonicalGroup,\n@@ -148,43 +148,52 @@ func (g *genFakeForType) GenerateType(c *generator.Context, t *types.Type, w io.\n \t\t\"ExtractFromListOptions\":         c.Universe.Function(types.Name{Package: pkgClientGoTesting, Name: \"ExtractFromListOptions\"}),\n \t}\n \n-\tnoMethods := extractBoolTagOrDie(\"noMethods\", t.SecondClosestCommentLines) == true\n-\n-\treadonly := extractBoolTagOrDie(\"readonly\", t.SecondClosestCommentLines) == true\n-\n-\tif namespaced {\n-\t\tsw.Do(structNamespaced, m)\n-\t} else {\n+\tif tags.NonNamespaced {\n \t\tsw.Do(structNonNamespaced, m)\n+\t} else {\n+\t\tsw.Do(structNamespaced, m)\n \t}\n \n-\tif !noMethods {\n-\t\tsw.Do(resource, m)\n-\t\tsw.Do(kind, m)\n+\tif tags.NoVerbs {\n+\t\treturn sw.Error()\n \t}\n+\tsw.Do(resource, m)\n+\tsw.Do(kind, m)\n \n-\tif !noMethods && !readonly {\n-\t\tsw.Do(createTemplate, m)\n-\t\tsw.Do(updateTemplate, m)\n-\t\t// Generate the UpdateStatus method if the type has a status\n-\t\tif genStatus(t) {\n-\t\t\tsw.Do(updateStatusTemplate, m)\n-\t\t}\n-\t\tsw.Do(deleteTemplate, m)\n-\t\tsw.Do(deleteCollectionTemplate, m)\n-\t}\n-\n-\tif !noMethods {\n+\tif tags.HasVerb(\"get\") {\n \t\tsw.Do(getTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"list\") {\n \t\tif hasObjectMeta(t) {\n \t\t\tsw.Do(listUsingOptionsTemplate, m)\n \t\t} else {\n \t\t\tsw.Do(listTemplate, m)\n \t\t}\n+\t}\n+\tif tags.HasVerb(\"watch\") {\n \t\tsw.Do(watchTemplate, m)\n \t}\n \n-\tif !noMethods && !readonly {\n+\tif tags.Readonly {\n+\t\treturn sw.Error()\n+\t}\n+\n+\tif tags.HasVerb(\"create\") {\n+\t\tsw.Do(createTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"update\") {\n+\t\tsw.Do(updateTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"updateStatus\") && genStatus(t) {\n+\t\tsw.Do(updateStatusTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"delete\") {\n+\t\tsw.Do(deleteTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"deleteCollection\") {\n+\t\tsw.Do(deleteCollectionTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"patch\") {\n \t\tsw.Do(patchTemplate, m)\n \t}\n "
  },
  {
    "sha": "02fd528bed5868049dc94558571e953ebb9b8108",
    "filename": "cmd/libs/go2idl/client-gen/generators/generator_for_group.go",
    "status": "modified",
    "additions": 8,
    "deletions": 4,
    "changes": 12,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/generator_for_group.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/generator_for_group.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/generator_for_group.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -23,6 +23,7 @@ import (\n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/namer\"\n \t\"k8s.io/gengo/types\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n \t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/path\"\n )\n \n@@ -101,15 +102,18 @@ func (g *genGroup) GenerateType(c *generator.Context, t *types.Type, w io.Writer\n \tsw.Do(groupInterfaceTemplate, m)\n \tsw.Do(groupClientTemplate, m)\n \tfor _, t := range g.types {\n+\t\ttags, err := util.ParseClientGenTags(t.SecondClosestCommentLines)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t\twrapper := map[string]interface{}{\n \t\t\t\"type\":         t,\n \t\t\t\"GroupVersion\": namer.IC(g.group) + namer.IC(g.version),\n \t\t}\n-\t\tnamespaced := !extractBoolTagOrDie(\"nonNamespaced\", t.SecondClosestCommentLines)\n-\t\tif namespaced {\n-\t\t\tsw.Do(getterImplNamespaced, wrapper)\n-\t\t} else {\n+\t\tif tags.NonNamespaced {\n \t\t\tsw.Do(getterImplNonNamespaced, wrapper)\n+\t\t} else {\n+\t\t\tsw.Do(getterImplNamespaced, wrapper)\n \t\t}\n \t}\n \tsw.Do(newClientForConfigTemplate, m)"
  },
  {
    "sha": "9a039f1747c448a122cc4c3f5143ea30de26a877",
    "filename": "cmd/libs/go2idl/client-gen/generators/generator_for_type.go",
    "status": "modified",
    "additions": 73,
    "deletions": 57,
    "changes": 130,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/generator_for_type.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/generator_for_type.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/generator_for_type.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -17,13 +17,14 @@ limitations under the License.\n package generators\n \n import (\n-\t\"fmt\"\n \t\"io\"\n \t\"path/filepath\"\n+\t\"strings\"\n \n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/namer\"\n \t\"k8s.io/gengo/types\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n )\n \n // genClientForType produces a file for each top-level type.\n@@ -64,25 +65,22 @@ func genStatus(t *types.Type) bool {\n \t\t\tbreak\n \t\t}\n \t}\n-\n-\t// Allow overriding via a comment on the type\n-\tgenStatus, err := types.ExtractSingleBoolCommentTag(\"+\", \"genclientstatus\", hasStatus, t.SecondClosestCommentLines)\n-\tif err != nil {\n-\t\tfmt.Printf(\"error looking up +genclientstatus: %v\\n\", err)\n-\t}\n-\treturn genStatus\n+\treturn hasStatus && !util.MustParseClientGenTags(t.SecondClosestCommentLines).NoStatus\n }\n \n // GenerateType makes the body of a file implementing the individual typed client for type t.\n func (g *genClientForType) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {\n \tsw := generator.NewSnippetWriter(w, c, \"$\", \"$\")\n \tpkg := filepath.Base(t.Name.Package)\n-\tnamespaced := !extractBoolTagOrDie(\"nonNamespaced\", t.SecondClosestCommentLines)\n+\ttags, err := util.ParseClientGenTags(t.SecondClosestCommentLines)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tm := map[string]interface{}{\n \t\t\"type\":                 t,\n \t\t\"package\":              pkg,\n \t\t\"Package\":              namer.IC(pkg),\n-\t\t\"namespaced\":           namespaced,\n+\t\t\"namespaced\":           !tags.NonNamespaced,\n \t\t\"Group\":                namer.IC(g.group),\n \t\t\"GroupVersion\":         namer.IC(g.group) + namer.IC(g.version),\n \t\t\"DeleteOptions\":        c.Universe.Type(types.Name{Package: \"k8s.io/apimachinery/pkg/apis/meta/v1\", Name: \"DeleteOptions\"}),\n@@ -95,74 +93,108 @@ func (g *genClientForType) GenerateType(c *generator.Context, t *types.Type, w i\n \t}\n \n \tsw.Do(getterComment, m)\n-\tif namespaced {\n-\t\tsw.Do(getterNamesapced, m)\n+\tif tags.NonNamespaced {\n+\t\tsw.Do(getterNonNamespaced, m)\n \t} else {\n-\t\tsw.Do(getterNonNamesapced, m)\n+\t\tsw.Do(getterNamespaced, m)\n \t}\n-\tnoMethods := extractBoolTagOrDie(\"noMethods\", t.SecondClosestCommentLines) == true\n-\n-\treadonly := extractBoolTagOrDie(\"readonly\", t.SecondClosestCommentLines) == true\n \n \tsw.Do(interfaceTemplate1, m)\n-\tif !noMethods {\n-\t\tif readonly {\n+\tif !tags.NoVerbs {\n+\t\tif tags.Readonly {\n \t\t\tsw.Do(interfaceTemplateReadonly, m)\n \t\t} else {\n-\t\t\tsw.Do(interfaceTemplate2, m)\n-\t\t\t// Include the UpdateStatus method if the type has a status\n-\t\t\tif genStatus(t) {\n-\t\t\t\tsw.Do(interfaceUpdateStatusTemplate, m)\n+\t\t\tif !genStatus(t) {\n+\t\t\t\ttags.SkipVerbs = append(tags.SkipVerbs, \"updateStatus\")\n \t\t\t}\n-\t\t\tsw.Do(interfaceTemplate3, m)\n+\t\t\tsw.Do(generateInterface(tags), m)\n \t\t}\n \t}\n \tsw.Do(interfaceTemplate4, m)\n \n-\tif namespaced {\n-\t\tsw.Do(structNamespaced, m)\n-\t\tsw.Do(newStructNamespaced, m)\n-\t} else {\n+\tif tags.NonNamespaced {\n \t\tsw.Do(structNonNamespaced, m)\n \t\tsw.Do(newStructNonNamespaced, m)\n+\t} else {\n+\t\tsw.Do(structNamespaced, m)\n+\t\tsw.Do(newStructNamespaced, m)\n \t}\n \n-\tif !noMethods && !readonly {\n-\t\tsw.Do(createTemplate, m)\n-\t\tsw.Do(updateTemplate, m)\n-\t\t// Generate the UpdateStatus method if the type has a status\n-\t\tif genStatus(t) {\n-\t\t\tsw.Do(updateStatusTemplate, m)\n-\t\t}\n-\t\tsw.Do(deleteTemplate, m)\n-\t\tsw.Do(deleteCollectionTemplate, m)\n+\tif tags.NoVerbs {\n+\t\treturn sw.Error()\n \t}\n \n-\tif !noMethods {\n+\tif tags.HasVerb(\"get\") {\n \t\tsw.Do(getTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"list\") {\n \t\tsw.Do(listTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"watch\") {\n \t\tsw.Do(watchTemplate, m)\n \t}\n \n-\tif !noMethods && !readonly {\n+\tif tags.Readonly {\n+\t\treturn sw.Error()\n+\t}\n+\n+\tif tags.HasVerb(\"create\") {\n+\t\tsw.Do(createTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"update\") {\n+\t\tsw.Do(updateTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"updateStatus\") {\n+\t\tsw.Do(updateStatusTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"delete\") {\n+\t\tsw.Do(deleteTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"deleteCollection\") {\n+\t\tsw.Do(deleteCollectionTemplate, m)\n+\t}\n+\tif tags.HasVerb(\"patch\") {\n \t\tsw.Do(patchTemplate, m)\n \t}\n \n \treturn sw.Error()\n }\n \n+func generateInterface(tags util.Tags) string {\n+\t// need an ordered list here to guarantee order of generated methods.\n+\tout := []string{}\n+\tfor _, m := range util.SupportedVerbs {\n+\t\tif tags.HasVerb(m) {\n+\t\t\tout = append(out, defaultVerbTemplates[m])\n+\t\t}\n+\t}\n+\treturn strings.Join(out, \"\\n\")\n+}\n+\n+var defaultVerbTemplates = map[string]string{\n+\t\"create\":           `Create(*$.type|raw$) (*$.type|raw$, error)`,\n+\t\"update\":           `Update(*$.type|raw$) (*$.type|raw$, error)`,\n+\t\"updateStatus\":     `UpdateStatus(*$.type|raw$) (*$.type|raw$, error)`,\n+\t\"delete\":           `Delete(name string, options *$.DeleteOptions|raw$) error`,\n+\t\"deleteCollection\": `DeleteCollection(options *$.DeleteOptions|raw$, listOptions $.ListOptions|raw$) error`,\n+\t\"get\":              `Get(name string, options $.GetOptions|raw$) (*$.type|raw$, error)`,\n+\t\"list\":             `List(opts $.ListOptions|raw$) (*$.type|raw$List, error)`,\n+\t\"watch\":            `Watch(opts $.ListOptions|raw$) ($.watchInterface|raw$, error)`,\n+\t\"patch\":            `Patch(name string, pt $.PatchType|raw$, data []byte, subresources ...string) (result *$.type|raw$, err error)`,\n+}\n+\n // group client will implement this interface.\n var getterComment = `\n // $.type|publicPlural$Getter has a method to return a $.type|public$Interface.\n // A group's client should implement this interface.`\n \n-var getterNamesapced = `\n+var getterNamespaced = `\n type $.type|publicPlural$Getter interface {\n \t$.type|publicPlural$(namespace string) $.type|public$Interface\n }\n `\n \n-var getterNonNamesapced = `\n+var getterNonNamespaced = `\n type $.type|publicPlural$Getter interface {\n \t$.type|publicPlural$() $.type|public$Interface\n }\n@@ -173,22 +205,6 @@ var interfaceTemplate1 = `\n // $.type|public$Interface has methods to work with $.type|public$ resources.\n type $.type|public$Interface interface {`\n \n-var interfaceTemplate2 = `\n-\tCreate(*$.type|raw$) (*$.type|raw$, error)\n-\tUpdate(*$.type|raw$) (*$.type|raw$, error)`\n-\n-var interfaceUpdateStatusTemplate = `\n-\tUpdateStatus(*$.type|raw$) (*$.type|raw$, error)`\n-\n-// template for the Interface\n-var interfaceTemplate3 = `\n-\tDelete(name string, options *$.DeleteOptions|raw$) error\n-\tDeleteCollection(options *$.DeleteOptions|raw$, listOptions $.ListOptions|raw$) error\n-\tGet(name string, options $.GetOptions|raw$) (*$.type|raw$, error)\n-\tList(opts $.ListOptions|raw$) (*$.type|raw$List, error)\n-\tWatch(opts $.ListOptions|raw$) ($.watchInterface|raw$, error)\n-\tPatch(name string, pt $.PatchType|raw$, data []byte, subresources ...string) (result *$.type|raw$, err error)`\n-\n var interfaceTemplateReadonly = `\n \tGet(name string, options $.GetOptions|raw$) (*$.type|raw$, error)\n \tList(opts $.ListOptions|raw$) (*$.type|raw$List, error)\n@@ -320,7 +336,7 @@ func (c *$.type|privatePlural$) Update($.type|private$ *$.type|raw$) (result *$.\n \n var updateStatusTemplate = `\n // UpdateStatus was generated because the type contains a Status member.\n-// Add a +genclientstatus=false comment above the type to avoid generating UpdateStatus().\n+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().\n \n func (c *$.type|privatePlural$) UpdateStatus($.type|private$ *$.type|raw$) (result *$.type|raw$, err error) {\n \tresult = &$.type|raw${}"
  },
  {
    "sha": "b00408103688118fbca3cf33fc274f342771ed74",
    "filename": "cmd/libs/go2idl/client-gen/generators/tags.go",
    "status": "modified",
    "additions": 0,
    "deletions": 12,
    "changes": 12,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/tags.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/tags.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/tags.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -17,21 +17,9 @@ limitations under the License.\n package generators\n \n import (\n-\t\"github.com/golang/glog\"\n \t\"k8s.io/gengo/types\"\n )\n \n-// extractBoolTagOrDie gets the comment-tags for the key and asserts that, if\n-// it exists, the value is boolean.  If the tag did not exist, it returns\n-// false.\n-func extractBoolTagOrDie(key string, lines []string) bool {\n-\tval, err := types.ExtractSingleBoolCommentTag(\"+\", key, false, lines)\n-\tif err != nil {\n-\t\tglog.Fatalf(err.Error())\n-\t}\n-\treturn val\n-}\n-\n // extractTag gets the comment-tags for the key.  If the tag did not exist, it\n // returns the empty string.\n func extractTag(key string, lines []string) string {"
  },
  {
    "sha": "186fc7821a12daab6e1c803d9540daa09a6a6e14",
    "filename": "cmd/libs/go2idl/client-gen/generators/util/BUILD",
    "status": "added",
    "additions": 36,
    "deletions": 0,
    "changes": 36,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/util/BUILD",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/util/BUILD",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/util/BUILD?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -0,0 +1,36 @@\n+package(default_visibility = [\"//visibility:public\"])\n+\n+licenses([\"notice\"])\n+\n+load(\n+    \"@io_bazel_rules_go//go:def.bzl\",\n+    \"go_library\",\n+    \"go_test\",\n+)\n+\n+go_test(\n+    name = \"go_default_test\",\n+    srcs = [\"tags_test.go\"],\n+    library = \":go_default_library\",\n+    tags = [\"automanaged\"],\n+)\n+\n+go_library(\n+    name = \"go_default_library\",\n+    srcs = [\"tags.go\"],\n+    tags = [\"automanaged\"],\n+    deps = [\"//vendor/k8s.io/gengo/types:go_default_library\"],\n+)\n+\n+filegroup(\n+    name = \"package-srcs\",\n+    srcs = glob([\"**\"]),\n+    tags = [\"automanaged\"],\n+    visibility = [\"//visibility:private\"],\n+)\n+\n+filegroup(\n+    name = \"all-srcs\",\n+    srcs = [\":package-srcs\"],\n+    tags = [\"automanaged\"],\n+)"
  },
  {
    "sha": "18ed8703efd47aa6c548897f711c71a967930420",
    "filename": "cmd/libs/go2idl/client-gen/generators/util/tags.go",
    "status": "added",
    "additions": 132,
    "deletions": 0,
    "changes": 132,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/util/tags.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/util/tags.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/util/tags.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -0,0 +1,132 @@\n+/*\n+Copyright 2016 The Kubernetes Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package util\n+\n+import (\n+\t\"errors\"\n+\t\"strings\"\n+\n+\t\"k8s.io/gengo/types\"\n+)\n+\n+var supportedTags = []string{\n+\t\"genclient\",\n+\t\"genclient:nonNamespaced\",\n+\t\"genclient:noVerbs\",\n+\t\"genclient:onlyVerbs\",\n+\t\"genclient:skipVerbs\",\n+\t\"genclient:noStatus\",\n+\t\"genclient:readonly\",\n+}\n+\n+// SupportedVerbs is a list of supported verbs for +onlyVerbs and +skipVerbs.\n+var SupportedVerbs = []string{\n+\t\"create\",\n+\t\"update\",\n+\t\"updateStatus\",\n+\t\"delete\",\n+\t\"deleteCollection\",\n+\t\"get\",\n+\t\"list\",\n+\t\"watch\",\n+\t\"patch\",\n+}\n+\n+// Tags represents a genclient configuration for a single type.\n+type Tags struct {\n+\t// +genclient\n+\tGenerateClient bool\n+\t// +genclient:nonNamespaced\n+\tNonNamespaced bool\n+\t// +genclient:noStatus\n+\tNoStatus bool\n+\t// +genclient:noVerbs\n+\tNoVerbs bool\n+\t// +genclient:skipVerbs=get,update\n+\t// +genclient:onlyVerbs=create,delete\n+\tSkipVerbs []string\n+\t// +genclient:readonly\n+\tReadonly bool\n+}\n+\n+// HasVerb returns true if we should include the given verb in final client interface and\n+// generate the function for it.\n+func (t Tags) HasVerb(verb string) bool {\n+\tif len(t.SkipVerbs) == 0 {\n+\t\treturn true\n+\t}\n+\tfor _, s := range t.SkipVerbs {\n+\t\tif verb == s {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// MustParseClientGenTags calls ParseClientGenTags but instead of returning error it panics.\n+func MustParseClientGenTags(lines []string) Tags {\n+\ttags, err := ParseClientGenTags(lines)\n+\tif err != nil {\n+\t\tpanic(err.Error())\n+\t}\n+\treturn tags\n+}\n+\n+// ParseClientGenTags parse the provided genclient tags and validates that no unknown\n+// tags are provided.\n+func ParseClientGenTags(lines []string) (Tags, error) {\n+\tret := Tags{}\n+\tvalues := types.ExtractCommentTags(\"+\", lines)\n+\t_, ret.GenerateClient = values[\"genclient\"]\n+\t_, ret.NonNamespaced = values[\"genclient:nonNamespaced\"]\n+\t_, ret.NoVerbs = values[\"genclient:noVerbs\"]\n+\t_, ret.NoStatus = values[\"genclient:noStatus\"]\n+\t_, ret.Readonly = values[\"genclient:readonly\"]\n+\tif v, exists := values[\"genclient:skipVerbs\"]; exists {\n+\t\tret.SkipVerbs = strings.Split(v[0], \",\")\n+\t}\n+\tif v, exists := values[\"genclient:onlyVerbs\"]; exists {\n+\t\tonlyVerbs := strings.Split(v[0], \",\")\n+\t\tret.SkipVerbs = []string{}\n+\t\tfor _, m := range SupportedVerbs {\n+\t\t\tskip := true\n+\t\t\tfor _, o := range onlyVerbs {\n+\t\t\t\tif o == m {\n+\t\t\t\t\tskip = false\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif skip {\n+\t\t\t\tret.SkipVerbs = append(ret.SkipVerbs, m)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn ret, validateClientGenTags(values)\n+}\n+\n+// validateTags validates that only supported genclient tags were provided.\n+func validateClientGenTags(values map[string][]string) error {\n+\tfor _, k := range supportedTags {\n+\t\tdelete(values, k)\n+\t}\n+\tfor key := range values {\n+\t\tif strings.HasPrefix(key, \"genclient\") {\n+\t\t\treturn errors.New(\"unknown tag detected: \" + key)\n+\t\t}\n+\t}\n+\treturn nil\n+}"
  },
  {
    "sha": "92f1a192ff5a7deedd34dcd52a8d4f2725fd95be",
    "filename": "cmd/libs/go2idl/client-gen/generators/util/tags_test.go",
    "status": "added",
    "additions": 64,
    "deletions": 0,
    "changes": 64,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/util/tags_test.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/generators/util/tags_test.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/generators/util/tags_test.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -0,0 +1,64 @@\n+/*\n+Copyright 2016 The Kubernetes Authors.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+*/\n+\n+package util\n+\n+import (\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+func TestParseTags(t *testing.T) {\n+\ttestCases := map[string]struct {\n+\t\tlines       []string\n+\t\texpectTags  Tags\n+\t\texpectError bool\n+\t}{\n+\t\t\"genclient\": {\n+\t\t\tlines:      []string{`+genclient`},\n+\t\t\texpectTags: Tags{GenerateClient: true},\n+\t\t},\n+\t\t\"genclient:nonNamespaced\": {\n+\t\t\tlines:      []string{`+genclient`, `+genclient:nonNamespaced`},\n+\t\t\texpectTags: Tags{GenerateClient: true, NonNamespaced: true},\n+\t\t},\n+\t\t\"genclient:noVerbs\": {\n+\t\t\tlines:      []string{`+genclient`, `+genclient:noVerbs`},\n+\t\t\texpectTags: Tags{GenerateClient: true, NoVerbs: true},\n+\t\t},\n+\t\t\"genclient:noStatus\": {\n+\t\t\tlines:      []string{`+genclient`, `+genclient:noStatus`},\n+\t\t\texpectTags: Tags{GenerateClient: true, NoStatus: true},\n+\t\t},\n+\t\t\"genclient:onlyVerbs\": {\n+\t\t\tlines:      []string{`+genclient`, `+genclient:onlyVerbs=create,delete`},\n+\t\t\texpectTags: Tags{GenerateClient: true, SkipVerbs: []string{\"update\", \"updateStatus\", \"deleteCollection\", \"get\", \"list\", \"watch\", \"patch\"}},\n+\t\t},\n+\t\t\"genclient:invalid\": {\n+\t\t\tlines:       []string{`+genclient`, `+genclient:invalid`},\n+\t\t\texpectError: true,\n+\t\t},\n+\t}\n+\tfor key, c := range testCases {\n+\t\tresult, err := ParseClientGenTags(c.lines)\n+\t\tif err != nil && !c.expectError {\n+\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t\t}\n+\t\tif !c.expectError && !reflect.DeepEqual(result, c.expectTags) {\n+\t\t\tt.Errorf(\"[%s] expected %#v to be %#v\", key, result, c.expectTags)\n+\t\t}\n+\t}\n+}"
  },
  {
    "sha": "6a6874f9cea0e7d13df0b7d80b45339d6728c34e",
    "filename": "cmd/libs/go2idl/client-gen/test_apis/testgroup/types.go",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/test_apis/testgroup/types.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/test_apis/testgroup/types.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/test_apis/testgroup/types.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -18,7 +18,7 @@ package testgroup\n \n import metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \n-// +genclient=true\n+// +genclient\n // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n \n type TestType struct {"
  },
  {
    "sha": "30852235175ce9f1a4f6bfa352329f1c584fbcca",
    "filename": "cmd/libs/go2idl/client-gen/test_apis/testgroup/v1/types.go",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/test_apis/testgroup/v1/types.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/test_apis/testgroup/v1/types.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/test_apis/testgroup/v1/types.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -18,7 +18,7 @@ package v1\n \n import metav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \n-// +genclient=true\n+// +genclient\n // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n \n type TestType struct {"
  },
  {
    "sha": "1e8f4b86b623dcaf958596fdad14755e82d02821",
    "filename": "cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/fake/fake_testtype.go",
    "status": "modified",
    "additions": 38,
    "deletions": 38,
    "changes": 76,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/fake/fake_testtype.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/fake/fake_testtype.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/fake/fake_testtype.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -36,6 +36,44 @@ var testtypesResource = schema.GroupVersionResource{Group: \"testgroup.k8s.io\", V\n \n var testtypesKind = schema.GroupVersionKind{Group: \"testgroup.k8s.io\", Version: \"\", Kind: \"TestType\"}\n \n+func (c *FakeTestTypes) Get(name string, options v1.GetOptions) (result *testgroup.TestType, err error) {\n+\tobj, err := c.Fake.\n+\t\tInvokes(testing.NewGetAction(testtypesResource, c.ns, name), &testgroup.TestType{})\n+\n+\tif obj == nil {\n+\t\treturn nil, err\n+\t}\n+\treturn obj.(*testgroup.TestType), err\n+}\n+\n+func (c *FakeTestTypes) List(opts v1.ListOptions) (result *testgroup.TestTypeList, err error) {\n+\tobj, err := c.Fake.\n+\t\tInvokes(testing.NewListAction(testtypesResource, testtypesKind, c.ns, opts), &testgroup.TestTypeList{})\n+\n+\tif obj == nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n+\tif label == nil {\n+\t\tlabel = labels.Everything()\n+\t}\n+\tlist := &testgroup.TestTypeList{}\n+\tfor _, item := range obj.(*testgroup.TestTypeList).Items {\n+\t\tif label.Matches(labels.Set(item.Labels)) {\n+\t\t\tlist.Items = append(list.Items, item)\n+\t\t}\n+\t}\n+\treturn list, err\n+}\n+\n+// Watch returns a watch.Interface that watches the requested testTypes.\n+func (c *FakeTestTypes) Watch(opts v1.ListOptions) (watch.Interface, error) {\n+\treturn c.Fake.\n+\t\tInvokesWatch(testing.NewWatchAction(testtypesResource, c.ns, opts))\n+\n+}\n+\n func (c *FakeTestTypes) Create(testType *testgroup.TestType) (result *testgroup.TestType, err error) {\n \tobj, err := c.Fake.\n \t\tInvokes(testing.NewCreateAction(testtypesResource, c.ns, testType), &testgroup.TestType{})\n@@ -80,44 +118,6 @@ func (c *FakeTestTypes) DeleteCollection(options *v1.DeleteOptions, listOptions\n \treturn err\n }\n \n-func (c *FakeTestTypes) Get(name string, options v1.GetOptions) (result *testgroup.TestType, err error) {\n-\tobj, err := c.Fake.\n-\t\tInvokes(testing.NewGetAction(testtypesResource, c.ns, name), &testgroup.TestType{})\n-\n-\tif obj == nil {\n-\t\treturn nil, err\n-\t}\n-\treturn obj.(*testgroup.TestType), err\n-}\n-\n-func (c *FakeTestTypes) List(opts v1.ListOptions) (result *testgroup.TestTypeList, err error) {\n-\tobj, err := c.Fake.\n-\t\tInvokes(testing.NewListAction(testtypesResource, testtypesKind, c.ns, opts), &testgroup.TestTypeList{})\n-\n-\tif obj == nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n-\tif label == nil {\n-\t\tlabel = labels.Everything()\n-\t}\n-\tlist := &testgroup.TestTypeList{}\n-\tfor _, item := range obj.(*testgroup.TestTypeList).Items {\n-\t\tif label.Matches(labels.Set(item.Labels)) {\n-\t\t\tlist.Items = append(list.Items, item)\n-\t\t}\n-\t}\n-\treturn list, err\n-}\n-\n-// Watch returns a watch.Interface that watches the requested testTypes.\n-func (c *FakeTestTypes) Watch(opts v1.ListOptions) (watch.Interface, error) {\n-\treturn c.Fake.\n-\t\tInvokesWatch(testing.NewWatchAction(testtypesResource, c.ns, opts))\n-\n-}\n-\n // Patch applies the patch and returns the patched testType.\n func (c *FakeTestTypes) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *testgroup.TestType, err error) {\n \tobj, err := c.Fake."
  },
  {
    "sha": "e63c5e54ad46393f2f636dc2cb7452906b3841b3",
    "filename": "cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/testtype.go",
    "status": "modified",
    "additions": 36,
    "deletions": 36,
    "changes": 72,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/testtype.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/testtype.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/client-gen/testoutput/clientset_generated/test_internalclientset/typed/testgroup/internalversion/testtype.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -59,6 +59,41 @@ func newTestTypes(c *TestgroupClient, namespace string) *testTypes {\n \t}\n }\n \n+// Get takes name of the testType, and returns the corresponding testType object, and an error if there is any.\n+func (c *testTypes) Get(name string, options v1.GetOptions) (result *testgroup.TestType, err error) {\n+\tresult = &testgroup.TestType{}\n+\terr = c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"testtypes\").\n+\t\tName(name).\n+\t\tVersionedParams(&options, scheme.ParameterCodec).\n+\t\tDo().\n+\t\tInto(result)\n+\treturn\n+}\n+\n+// List takes label and field selectors, and returns the list of TestTypes that match those selectors.\n+func (c *testTypes) List(opts v1.ListOptions) (result *testgroup.TestTypeList, err error) {\n+\tresult = &testgroup.TestTypeList{}\n+\terr = c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"testtypes\").\n+\t\tVersionedParams(&opts, scheme.ParameterCodec).\n+\t\tDo().\n+\t\tInto(result)\n+\treturn\n+}\n+\n+// Watch returns a watch.Interface that watches the requested testTypes.\n+func (c *testTypes) Watch(opts v1.ListOptions) (watch.Interface, error) {\n+\topts.Watch = true\n+\treturn c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"testtypes\").\n+\t\tVersionedParams(&opts, scheme.ParameterCodec).\n+\t\tWatch()\n+}\n+\n // Create takes the representation of a testType and creates it.  Returns the server's representation of the testType, and an error, if there is any.\n func (c *testTypes) Create(testType *testgroup.TestType) (result *testgroup.TestType, err error) {\n \tresult = &testgroup.TestType{}\n@@ -85,7 +120,7 @@ func (c *testTypes) Update(testType *testgroup.TestType) (result *testgroup.Test\n }\n \n // UpdateStatus was generated because the type contains a Status member.\n-// Add a +genclientstatus=false comment above the type to avoid generating UpdateStatus().\n+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().\n \n func (c *testTypes) UpdateStatus(testType *testgroup.TestType) (result *testgroup.TestType, err error) {\n \tresult = &testgroup.TestType{}\n@@ -122,41 +157,6 @@ func (c *testTypes) DeleteCollection(options *v1.DeleteOptions, listOptions v1.L\n \t\tError()\n }\n \n-// Get takes name of the testType, and returns the corresponding testType object, and an error if there is any.\n-func (c *testTypes) Get(name string, options v1.GetOptions) (result *testgroup.TestType, err error) {\n-\tresult = &testgroup.TestType{}\n-\terr = c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"testtypes\").\n-\t\tName(name).\n-\t\tVersionedParams(&options, scheme.ParameterCodec).\n-\t\tDo().\n-\t\tInto(result)\n-\treturn\n-}\n-\n-// List takes label and field selectors, and returns the list of TestTypes that match those selectors.\n-func (c *testTypes) List(opts v1.ListOptions) (result *testgroup.TestTypeList, err error) {\n-\tresult = &testgroup.TestTypeList{}\n-\terr = c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"testtypes\").\n-\t\tVersionedParams(&opts, scheme.ParameterCodec).\n-\t\tDo().\n-\t\tInto(result)\n-\treturn\n-}\n-\n-// Watch returns a watch.Interface that watches the requested testTypes.\n-func (c *testTypes) Watch(opts v1.ListOptions) (watch.Interface, error) {\n-\topts.Watch = true\n-\treturn c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"testtypes\").\n-\t\tVersionedParams(&opts, scheme.ParameterCodec).\n-\t\tWatch()\n-}\n-\n // Patch applies the patch and returns the patched testType.\n func (c *testTypes) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *testgroup.TestType, err error) {\n \tresult = &testgroup.TestType{}"
  },
  {
    "sha": "fa2eb04234f362c1e7e6b977e0611f01b6c84b5c",
    "filename": "cmd/libs/go2idl/informer-gen/generators/BUILD",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/informer-gen/generators/BUILD",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/informer-gen/generators/BUILD",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/informer-gen/generators/BUILD?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -17,12 +17,12 @@ go_library(\n         \"groupinterface.go\",\n         \"informer.go\",\n         \"packages.go\",\n-        \"tags.go\",\n         \"types.go\",\n         \"versioninterface.go\",\n     ],\n     tags = [\"automanaged\"],\n     deps = [\n+        \"//cmd/libs/go2idl/client-gen/generators/util:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/types:go_default_library\",\n         \"//vendor/github.com/golang/glog:go_default_library\",\n         \"//vendor/github.com/spf13/pflag:go_default_library\","
  },
  {
    "sha": "5dd2bce2a22509b44c710f65d2df8ceee583c8aa",
    "filename": "cmd/libs/go2idl/informer-gen/generators/informer.go",
    "status": "modified",
    "additions": 7,
    "deletions": 1,
    "changes": 8,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/informer-gen/generators/informer.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/informer-gen/generators/informer.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/informer-gen/generators/informer.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -24,6 +24,7 @@ import (\n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/namer\"\n \t\"k8s.io/gengo/types\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n \tclientgentypes \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types\"\n \n \t\"github.com/golang/glog\"\n@@ -69,6 +70,11 @@ func (g *informerGenerator) GenerateType(c *generator.Context, t *types.Type, w\n \tclientSetInterface := c.Universe.Type(types.Name{Package: g.clientSetPackage, Name: \"Interface\"})\n \tinformerFor := \"InformerFor\"\n \n+\ttags, err := util.ParseClientGenTags(t.SecondClosestCommentLines)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n \tm := map[string]interface{}{\n \t\t\"apiScheme\":                       c.Universe.Type(apiScheme),\n \t\t\"cacheIndexers\":                   c.Universe.Type(cacheIndexers),\n@@ -84,7 +90,7 @@ func (g *informerGenerator) GenerateType(c *generator.Context, t *types.Type, w\n \t\t\"listOptions\":                     c.Universe.Type(listOptions),\n \t\t\"lister\":                          c.Universe.Type(types.Name{Package: listerPackage, Name: t.Name.Name + \"Lister\"}),\n \t\t\"namespaceAll\":                    c.Universe.Type(metav1NamespaceAll),\n-\t\t\"namespaced\":                      !extractBoolTagOrDie(\"nonNamespaced\", t.SecondClosestCommentLines),\n+\t\t\"namespaced\":                      !tags.NonNamespaced,\n \t\t\"newLister\":                       c.Universe.Function(types.Name{Package: listerPackage, Name: \"New\" + t.Name.Name + \"Lister\"}),\n \t\t\"runtimeObject\":                   c.Universe.Type(runtimeObject),\n \t\t\"timeDuration\":                    c.Universe.Type(timeDuration),"
  },
  {
    "sha": "ee567a733a715eb9f8f24617831649cad9e9d3e8",
    "filename": "cmd/libs/go2idl/informer-gen/generators/packages.go",
    "status": "modified",
    "additions": 6,
    "deletions": 12,
    "changes": 18,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/informer-gen/generators/packages.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/informer-gen/generators/packages.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/informer-gen/generators/packages.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -25,6 +25,7 @@ import (\n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/namer\"\n \t\"k8s.io/gengo/types\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n \tclientgentypes \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types\"\n \n \t\"github.com/golang/glog\"\n@@ -69,8 +70,7 @@ func generatedBy() string {\n func objectMetaForPackage(p *types.Package) (*types.Type, bool, error) {\n \tgeneratingForPackage := false\n \tfor _, t := range p.Types {\n-\t\t// filter out types which dont have genclient=true.\n-\t\tif extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == false {\n+\t\tif !util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient {\n \t\t\tcontinue\n \t\t}\n \t\tgeneratingForPackage = true\n@@ -166,12 +166,8 @@ func Packages(context *generator.Context, arguments *args.GeneratorArgs) generat\n \n \t\tvar typesToGenerate []*types.Type\n \t\tfor _, t := range p.Types {\n-\t\t\t// filter out types which dont have genclient=true.\n-\t\t\tif extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == false {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\t// filter out types which have noMethods\n-\t\t\tif extractBoolTagOrDie(\"noMethods\", t.SecondClosestCommentLines) == true {\n+\t\t\ttags := util.MustParseClientGenTags(t.SecondClosestCommentLines)\n+\t\t\tif !tags.GenerateClient || tags.NoVerbs {\n \t\t\t\tcontinue\n \t\t\t}\n \n@@ -299,8 +295,7 @@ func groupPackage(basePackage string, groupVersions clientgentypes.GroupVersions\n \t\t\treturn generators\n \t\t},\n \t\tFilterFunc: func(c *generator.Context, t *types.Type) bool {\n-\t\t\t// piggy-back on types that are tagged for client-gen\n-\t\t\treturn extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == true\n+\t\t\treturn util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient\n \t\t},\n \t}\n }\n@@ -340,8 +335,7 @@ func versionPackage(basePackage string, gv clientgentypes.GroupVersion, boilerpl\n \t\t\treturn generators\n \t\t},\n \t\tFilterFunc: func(c *generator.Context, t *types.Type) bool {\n-\t\t\t// piggy-back on types that are tagged for client-gen\n-\t\t\treturn extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == true\n+\t\t\treturn util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient\n \t\t},\n \t}\n }"
  },
  {
    "sha": "34aa77231fa9b81f4700b1269a850829f483ab7f",
    "filename": "cmd/libs/go2idl/informer-gen/generators/tags.go",
    "status": "removed",
    "additions": 0,
    "deletions": 33,
    "changes": 33,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/d74ac3785eafd8644a1ac2c9757f613105d76a4f/cmd/libs/go2idl/informer-gen/generators/tags.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/d74ac3785eafd8644a1ac2c9757f613105d76a4f/cmd/libs/go2idl/informer-gen/generators/tags.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/informer-gen/generators/tags.go?ref=d74ac3785eafd8644a1ac2c9757f613105d76a4f",
    "patch": "@@ -1,33 +0,0 @@\n-/*\n-Copyright 2016 The Kubernetes Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-*/\n-\n-package generators\n-\n-import (\n-\t\"github.com/golang/glog\"\n-\t\"k8s.io/gengo/types\"\n-)\n-\n-// extractBoolTagOrDie gets the comment-tags for the key and asserts that, if\n-// it exists, the value is boolean.  If the tag did not exist, it returns\n-// false.\n-func extractBoolTagOrDie(key string, lines []string) bool {\n-\tval, err := types.ExtractSingleBoolCommentTag(\"+\", key, false, lines)\n-\tif err != nil {\n-\t\tglog.Fatalf(err.Error())\n-\t}\n-\treturn val\n-}"
  },
  {
    "sha": "5b70e7b8f90d576e1ef7b5fdd12de7bce3969de1",
    "filename": "cmd/libs/go2idl/lister-gen/generators/BUILD",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/lister-gen/generators/BUILD",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/lister-gen/generators/BUILD",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/lister-gen/generators/BUILD?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -12,10 +12,10 @@ go_library(\n     srcs = [\n         \"expansion.go\",\n         \"lister.go\",\n-        \"tags.go\",\n     ],\n     tags = [\"automanaged\"],\n     deps = [\n+        \"//cmd/libs/go2idl/client-gen/generators/util:go_default_library\",\n         \"//cmd/libs/go2idl/client-gen/types:go_default_library\",\n         \"//vendor/github.com/golang/glog:go_default_library\",\n         \"//vendor/k8s.io/gengo/args:go_default_library\","
  },
  {
    "sha": "ab34e81b5d58bfe98ebd4f2145b60206db4816aa",
    "filename": "cmd/libs/go2idl/lister-gen/generators/expansion.go",
    "status": "modified",
    "additions": 3,
    "deletions": 2,
    "changes": 5,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/lister-gen/generators/expansion.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/lister-gen/generators/expansion.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/lister-gen/generators/expansion.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -24,6 +24,7 @@ import (\n \n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/types\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n )\n \n // expansionGenerator produces a file for a expansion interfaces.\n@@ -41,10 +42,10 @@ func (g *expansionGenerator) Filter(c *generator.Context, t *types.Type) bool {\n func (g *expansionGenerator) GenerateType(c *generator.Context, t *types.Type, w io.Writer) error {\n \tsw := generator.NewSnippetWriter(w, c, \"$\", \"$\")\n \tfor _, t := range g.types {\n+\t\ttags := util.MustParseClientGenTags(t.SecondClosestCommentLines)\n \t\tif _, err := os.Stat(filepath.Join(g.packagePath, strings.ToLower(t.Name.Name+\"_expansion.go\"))); os.IsNotExist(err) {\n \t\t\tsw.Do(expansionInterfaceTemplate, t)\n-\t\t\tnamespaced := !extractBoolTagOrDie(\"nonNamespaced\", t.SecondClosestCommentLines)\n-\t\t\tif namespaced {\n+\t\t\tif !tags.NonNamespaced {\n \t\t\t\tsw.Do(namespacedExpansionInterfaceTemplate, t)\n \t\t\t}\n \t\t}"
  },
  {
    "sha": "e859888c70cee542713da941aef3d64dd33064fd",
    "filename": "cmd/libs/go2idl/lister-gen/generators/lister.go",
    "status": "modified",
    "additions": 20,
    "deletions": 16,
    "changes": 36,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/lister-gen/generators/lister.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/cmd/libs/go2idl/lister-gen/generators/lister.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/lister-gen/generators/lister.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -26,6 +26,7 @@ import (\n \t\"k8s.io/gengo/generator\"\n \t\"k8s.io/gengo/namer\"\n \t\"k8s.io/gengo/types\"\n+\t\"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/generators/util\"\n \tclientgentypes \"k8s.io/kubernetes/cmd/libs/go2idl/client-gen/types\"\n \n \t\"github.com/golang/glog\"\n@@ -115,8 +116,7 @@ func Packages(context *generator.Context, arguments *args.GeneratorArgs) generat\n \n \t\tvar typesToGenerate []*types.Type\n \t\tfor _, t := range p.Types {\n-\t\t\t// filter out types which dont have genclient=true.\n-\t\t\tif extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == false {\n+\t\t\tif !util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\ttypesToGenerate = append(typesToGenerate, t)\n@@ -154,8 +154,7 @@ func Packages(context *generator.Context, arguments *args.GeneratorArgs) generat\n \t\t\t\treturn generators\n \t\t\t},\n \t\t\tFilterFunc: func(c *generator.Context, t *types.Type) bool {\n-\t\t\t\t// piggy-back on types that are tagged for client-gen\n-\t\t\t\treturn extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == true\n+\t\t\t\treturn util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient\n \t\t\t},\n \t\t})\n \t}\n@@ -168,7 +167,7 @@ func objectMetaForPackage(p *types.Package) (*types.Type, bool, error) {\n \tgeneratingForPackage := false\n \tfor _, t := range p.Types {\n \t\t// filter out types which dont have genclient=true.\n-\t\tif extractBoolTagOrDie(\"genclient\", t.SecondClosestCommentLines) == false {\n+\t\tif !util.MustParseClientGenTags(t.SecondClosestCommentLines).GenerateClient {\n \t\t\tcontinue\n \t\t}\n \t\tgeneratingForPackage = true\n@@ -232,27 +231,32 @@ func (g *listerGenerator) GenerateType(c *generator.Context, t *types.Type, w io\n \t\t\"objectMeta\": g.objectMeta,\n \t}\n \n-\tnamespaced := !extractBoolTagOrDie(\"nonNamespaced\", t.SecondClosestCommentLines)\n-\tif namespaced {\n-\t\tsw.Do(typeListerInterface, m)\n-\t} else {\n+\ttags, err := util.ParseClientGenTags(t.SecondClosestCommentLines)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif tags.NonNamespaced {\n \t\tsw.Do(typeListerInterface_NonNamespaced, m)\n+\t} else {\n+\t\tsw.Do(typeListerInterface, m)\n \t}\n \n \tsw.Do(typeListerStruct, m)\n \tsw.Do(typeListerConstructor, m)\n \tsw.Do(typeLister_List, m)\n \n-\tif namespaced {\n-\t\tsw.Do(typeLister_NamespaceLister, m)\n-\t\tsw.Do(namespaceListerInterface, m)\n-\t\tsw.Do(namespaceListerStruct, m)\n-\t\tsw.Do(namespaceLister_List, m)\n-\t\tsw.Do(namespaceLister_Get, m)\n-\t} else {\n+\tif tags.NonNamespaced {\n \t\tsw.Do(typeLister_NonNamespacedGet, m)\n+\t\treturn sw.Error()\n \t}\n \n+\tsw.Do(typeLister_NamespaceLister, m)\n+\tsw.Do(namespaceListerInterface, m)\n+\tsw.Do(namespaceListerStruct, m)\n+\tsw.Do(namespaceLister_List, m)\n+\tsw.Do(namespaceLister_Get, m)\n+\n \treturn sw.Error()\n }\n "
  },
  {
    "sha": "34aa77231fa9b81f4700b1269a850829f483ab7f",
    "filename": "cmd/libs/go2idl/lister-gen/generators/tags.go",
    "status": "removed",
    "additions": 0,
    "deletions": 33,
    "changes": 33,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/d74ac3785eafd8644a1ac2c9757f613105d76a4f/cmd/libs/go2idl/lister-gen/generators/tags.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/d74ac3785eafd8644a1ac2c9757f613105d76a4f/cmd/libs/go2idl/lister-gen/generators/tags.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/cmd/libs/go2idl/lister-gen/generators/tags.go?ref=d74ac3785eafd8644a1ac2c9757f613105d76a4f",
    "patch": "@@ -1,33 +0,0 @@\n-/*\n-Copyright 2016 The Kubernetes Authors.\n-\n-Licensed under the Apache License, Version 2.0 (the \"License\");\n-you may not use this file except in compliance with the License.\n-You may obtain a copy of the License at\n-\n-    http://www.apache.org/licenses/LICENSE-2.0\n-\n-Unless required by applicable law or agreed to in writing, software\n-distributed under the License is distributed on an \"AS IS\" BASIS,\n-WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-See the License for the specific language governing permissions and\n-limitations under the License.\n-*/\n-\n-package generators\n-\n-import (\n-\t\"github.com/golang/glog\"\n-\t\"k8s.io/gengo/types\"\n-)\n-\n-// extractBoolTagOrDie gets the comment-tags for the key and asserts that, if\n-// it exists, the value is boolean.  If the tag did not exist, it returns\n-// false.\n-func extractBoolTagOrDie(key string, lines []string) bool {\n-\tval, err := types.ExtractSingleBoolCommentTag(\"+\", key, false, lines)\n-\tif err != nil {\n-\t\tglog.Fatalf(err.Error())\n-\t}\n-\treturn val\n-}"
  },
  {
    "sha": "d8cb94408a69a58a4dbd00c894f05d2bb56ef8b5",
    "filename": "federation/apis/federation/types.go",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/federation/apis/federation/types.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/federation/apis/federation/types.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/federation/apis/federation/types.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -92,7 +92,7 @@ type ClusterStatus struct {\n }\n \n // +genclient=true\n-// +nonNamespaced=true\n+// +genclient:nonNamespaced\n // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n \n // Information about a registered cluster in a federated kubernetes setup. Clusters are not namespaced and have unique names in the federation."
  },
  {
    "sha": "e3f0a4ac05e2fbfc90bac2c2597c5535d8f61886",
    "filename": "federation/apis/federation/v1beta1/types.go",
    "status": "modified",
    "additions": 1,
    "deletions": 1,
    "changes": 2,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/federation/apis/federation/v1beta1/types.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/federation/apis/federation/v1beta1/types.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/federation/apis/federation/v1beta1/types.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -94,7 +94,7 @@ type ClusterStatus struct {\n \n // +genclient=true\n // +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n-// +nonNamespaced=true\n+// +genclient:nonNamespaced\n \n // Information about a registered cluster in a federated kubernetes setup. Clusters are not namespaced and have unique names in the federation.\n type Cluster struct {"
  },
  {
    "sha": "1b80a91b530292751e526c4650d070c8028274b7",
    "filename": "federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/fake/fake_horizontalpodautoscaler.go",
    "status": "modified",
    "additions": 47,
    "deletions": 47,
    "changes": 94,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/fake/fake_horizontalpodautoscaler.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/fake/fake_horizontalpodautoscaler.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/fake/fake_horizontalpodautoscaler.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -17,8 +17,8 @@ limitations under the License.\n package fake\n \n import (\n-\tv1 \"k8s.io/api/autoscaling/v1\"\n-\tmeta_v1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\tautoscaling_v1 \"k8s.io/api/autoscaling/v1\"\n+\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \tlabels \"k8s.io/apimachinery/pkg/labels\"\n \tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n \ttypes \"k8s.io/apimachinery/pkg/types\"\n@@ -36,95 +36,95 @@ var horizontalpodautoscalersResource = schema.GroupVersionResource{Group: \"autos\n \n var horizontalpodautoscalersKind = schema.GroupVersionKind{Group: \"autoscaling\", Version: \"v1\", Kind: \"HorizontalPodAutoscaler\"}\n \n-func (c *FakeHorizontalPodAutoscalers) Create(horizontalPodAutoscaler *v1.HorizontalPodAutoscaler) (result *v1.HorizontalPodAutoscaler, err error) {\n+func (c *FakeHorizontalPodAutoscalers) Get(name string, options v1.GetOptions) (result *autoscaling_v1.HorizontalPodAutoscaler, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewCreateAction(horizontalpodautoscalersResource, c.ns, horizontalPodAutoscaler), &v1.HorizontalPodAutoscaler{})\n+\t\tInvokes(testing.NewGetAction(horizontalpodautoscalersResource, c.ns, name), &autoscaling_v1.HorizontalPodAutoscaler{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.HorizontalPodAutoscaler), err\n+\treturn obj.(*autoscaling_v1.HorizontalPodAutoscaler), err\n }\n \n-func (c *FakeHorizontalPodAutoscalers) Update(horizontalPodAutoscaler *v1.HorizontalPodAutoscaler) (result *v1.HorizontalPodAutoscaler, err error) {\n+func (c *FakeHorizontalPodAutoscalers) List(opts v1.ListOptions) (result *autoscaling_v1.HorizontalPodAutoscalerList, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewUpdateAction(horizontalpodautoscalersResource, c.ns, horizontalPodAutoscaler), &v1.HorizontalPodAutoscaler{})\n+\t\tInvokes(testing.NewListAction(horizontalpodautoscalersResource, horizontalpodautoscalersKind, c.ns, opts), &autoscaling_v1.HorizontalPodAutoscalerList{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.HorizontalPodAutoscaler), err\n-}\n-\n-func (c *FakeHorizontalPodAutoscalers) UpdateStatus(horizontalPodAutoscaler *v1.HorizontalPodAutoscaler) (*v1.HorizontalPodAutoscaler, error) {\n-\tobj, err := c.Fake.\n-\t\tInvokes(testing.NewUpdateSubresourceAction(horizontalpodautoscalersResource, \"status\", c.ns, horizontalPodAutoscaler), &v1.HorizontalPodAutoscaler{})\n \n-\tif obj == nil {\n-\t\treturn nil, err\n+\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n+\tif label == nil {\n+\t\tlabel = labels.Everything()\n \t}\n-\treturn obj.(*v1.HorizontalPodAutoscaler), err\n+\tlist := &autoscaling_v1.HorizontalPodAutoscalerList{}\n+\tfor _, item := range obj.(*autoscaling_v1.HorizontalPodAutoscalerList).Items {\n+\t\tif label.Matches(labels.Set(item.Labels)) {\n+\t\t\tlist.Items = append(list.Items, item)\n+\t\t}\n+\t}\n+\treturn list, err\n }\n \n-func (c *FakeHorizontalPodAutoscalers) Delete(name string, options *meta_v1.DeleteOptions) error {\n-\t_, err := c.Fake.\n-\t\tInvokes(testing.NewDeleteAction(horizontalpodautoscalersResource, c.ns, name), &v1.HorizontalPodAutoscaler{})\n+// Watch returns a watch.Interface that watches the requested horizontalPodAutoscalers.\n+func (c *FakeHorizontalPodAutoscalers) Watch(opts v1.ListOptions) (watch.Interface, error) {\n+\treturn c.Fake.\n+\t\tInvokesWatch(testing.NewWatchAction(horizontalpodautoscalersResource, c.ns, opts))\n \n-\treturn err\n }\n \n-func (c *FakeHorizontalPodAutoscalers) DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error {\n-\taction := testing.NewDeleteCollectionAction(horizontalpodautoscalersResource, c.ns, listOptions)\n+func (c *FakeHorizontalPodAutoscalers) Create(horizontalPodAutoscaler *autoscaling_v1.HorizontalPodAutoscaler) (result *autoscaling_v1.HorizontalPodAutoscaler, err error) {\n+\tobj, err := c.Fake.\n+\t\tInvokes(testing.NewCreateAction(horizontalpodautoscalersResource, c.ns, horizontalPodAutoscaler), &autoscaling_v1.HorizontalPodAutoscaler{})\n \n-\t_, err := c.Fake.Invokes(action, &v1.HorizontalPodAutoscalerList{})\n-\treturn err\n+\tif obj == nil {\n+\t\treturn nil, err\n+\t}\n+\treturn obj.(*autoscaling_v1.HorizontalPodAutoscaler), err\n }\n \n-func (c *FakeHorizontalPodAutoscalers) Get(name string, options meta_v1.GetOptions) (result *v1.HorizontalPodAutoscaler, err error) {\n+func (c *FakeHorizontalPodAutoscalers) Update(horizontalPodAutoscaler *autoscaling_v1.HorizontalPodAutoscaler) (result *autoscaling_v1.HorizontalPodAutoscaler, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewGetAction(horizontalpodautoscalersResource, c.ns, name), &v1.HorizontalPodAutoscaler{})\n+\t\tInvokes(testing.NewUpdateAction(horizontalpodautoscalersResource, c.ns, horizontalPodAutoscaler), &autoscaling_v1.HorizontalPodAutoscaler{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.HorizontalPodAutoscaler), err\n+\treturn obj.(*autoscaling_v1.HorizontalPodAutoscaler), err\n }\n \n-func (c *FakeHorizontalPodAutoscalers) List(opts meta_v1.ListOptions) (result *v1.HorizontalPodAutoscalerList, err error) {\n+func (c *FakeHorizontalPodAutoscalers) UpdateStatus(horizontalPodAutoscaler *autoscaling_v1.HorizontalPodAutoscaler) (*autoscaling_v1.HorizontalPodAutoscaler, error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewListAction(horizontalpodautoscalersResource, horizontalpodautoscalersKind, c.ns, opts), &v1.HorizontalPodAutoscalerList{})\n+\t\tInvokes(testing.NewUpdateSubresourceAction(horizontalpodautoscalersResource, \"status\", c.ns, horizontalPodAutoscaler), &autoscaling_v1.HorizontalPodAutoscaler{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n+\treturn obj.(*autoscaling_v1.HorizontalPodAutoscaler), err\n+}\n \n-\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n-\tif label == nil {\n-\t\tlabel = labels.Everything()\n-\t}\n-\tlist := &v1.HorizontalPodAutoscalerList{}\n-\tfor _, item := range obj.(*v1.HorizontalPodAutoscalerList).Items {\n-\t\tif label.Matches(labels.Set(item.Labels)) {\n-\t\t\tlist.Items = append(list.Items, item)\n-\t\t}\n-\t}\n-\treturn list, err\n+func (c *FakeHorizontalPodAutoscalers) Delete(name string, options *v1.DeleteOptions) error {\n+\t_, err := c.Fake.\n+\t\tInvokes(testing.NewDeleteAction(horizontalpodautoscalersResource, c.ns, name), &autoscaling_v1.HorizontalPodAutoscaler{})\n+\n+\treturn err\n }\n \n-// Watch returns a watch.Interface that watches the requested horizontalPodAutoscalers.\n-func (c *FakeHorizontalPodAutoscalers) Watch(opts meta_v1.ListOptions) (watch.Interface, error) {\n-\treturn c.Fake.\n-\t\tInvokesWatch(testing.NewWatchAction(horizontalpodautoscalersResource, c.ns, opts))\n+func (c *FakeHorizontalPodAutoscalers) DeleteCollection(options *v1.DeleteOptions, listOptions v1.ListOptions) error {\n+\taction := testing.NewDeleteCollectionAction(horizontalpodautoscalersResource, c.ns, listOptions)\n \n+\t_, err := c.Fake.Invokes(action, &autoscaling_v1.HorizontalPodAutoscalerList{})\n+\treturn err\n }\n \n // Patch applies the patch and returns the patched horizontalPodAutoscaler.\n-func (c *FakeHorizontalPodAutoscalers) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.HorizontalPodAutoscaler, err error) {\n+func (c *FakeHorizontalPodAutoscalers) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *autoscaling_v1.HorizontalPodAutoscaler, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewPatchSubresourceAction(horizontalpodautoscalersResource, c.ns, name, data, subresources...), &v1.HorizontalPodAutoscaler{})\n+\t\tInvokes(testing.NewPatchSubresourceAction(horizontalpodautoscalersResource, c.ns, name, data, subresources...), &autoscaling_v1.HorizontalPodAutoscaler{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.HorizontalPodAutoscaler), err\n+\treturn obj.(*autoscaling_v1.HorizontalPodAutoscaler), err\n }"
  },
  {
    "sha": "980221240cc00145c6c355a9d8c4cb27bcaca2e2",
    "filename": "federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/horizontalpodautoscaler.go",
    "status": "modified",
    "additions": 36,
    "deletions": 36,
    "changes": 72,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/horizontalpodautoscaler.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/horizontalpodautoscaler.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/federation/client/clientset_generated/federation_clientset/typed/autoscaling/v1/horizontalpodautoscaler.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -59,6 +59,41 @@ func newHorizontalPodAutoscalers(c *AutoscalingV1Client, namespace string) *hori\n \t}\n }\n \n+// Get takes name of the horizontalPodAutoscaler, and returns the corresponding horizontalPodAutoscaler object, and an error if there is any.\n+func (c *horizontalPodAutoscalers) Get(name string, options meta_v1.GetOptions) (result *v1.HorizontalPodAutoscaler, err error) {\n+\tresult = &v1.HorizontalPodAutoscaler{}\n+\terr = c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"horizontalpodautoscalers\").\n+\t\tName(name).\n+\t\tVersionedParams(&options, scheme.ParameterCodec).\n+\t\tDo().\n+\t\tInto(result)\n+\treturn\n+}\n+\n+// List takes label and field selectors, and returns the list of HorizontalPodAutoscalers that match those selectors.\n+func (c *horizontalPodAutoscalers) List(opts meta_v1.ListOptions) (result *v1.HorizontalPodAutoscalerList, err error) {\n+\tresult = &v1.HorizontalPodAutoscalerList{}\n+\terr = c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"horizontalpodautoscalers\").\n+\t\tVersionedParams(&opts, scheme.ParameterCodec).\n+\t\tDo().\n+\t\tInto(result)\n+\treturn\n+}\n+\n+// Watch returns a watch.Interface that watches the requested horizontalPodAutoscalers.\n+func (c *horizontalPodAutoscalers) Watch(opts meta_v1.ListOptions) (watch.Interface, error) {\n+\topts.Watch = true\n+\treturn c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"horizontalpodautoscalers\").\n+\t\tVersionedParams(&opts, scheme.ParameterCodec).\n+\t\tWatch()\n+}\n+\n // Create takes the representation of a horizontalPodAutoscaler and creates it.  Returns the server's representation of the horizontalPodAutoscaler, and an error, if there is any.\n func (c *horizontalPodAutoscalers) Create(horizontalPodAutoscaler *v1.HorizontalPodAutoscaler) (result *v1.HorizontalPodAutoscaler, err error) {\n \tresult = &v1.HorizontalPodAutoscaler{}\n@@ -85,7 +120,7 @@ func (c *horizontalPodAutoscalers) Update(horizontalPodAutoscaler *v1.Horizontal\n }\n \n // UpdateStatus was generated because the type contains a Status member.\n-// Add a +genclientstatus=false comment above the type to avoid generating UpdateStatus().\n+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().\n \n func (c *horizontalPodAutoscalers) UpdateStatus(horizontalPodAutoscaler *v1.HorizontalPodAutoscaler) (result *v1.HorizontalPodAutoscaler, err error) {\n \tresult = &v1.HorizontalPodAutoscaler{}\n@@ -122,41 +157,6 @@ func (c *horizontalPodAutoscalers) DeleteCollection(options *meta_v1.DeleteOptio\n \t\tError()\n }\n \n-// Get takes name of the horizontalPodAutoscaler, and returns the corresponding horizontalPodAutoscaler object, and an error if there is any.\n-func (c *horizontalPodAutoscalers) Get(name string, options meta_v1.GetOptions) (result *v1.HorizontalPodAutoscaler, err error) {\n-\tresult = &v1.HorizontalPodAutoscaler{}\n-\terr = c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"horizontalpodautoscalers\").\n-\t\tName(name).\n-\t\tVersionedParams(&options, scheme.ParameterCodec).\n-\t\tDo().\n-\t\tInto(result)\n-\treturn\n-}\n-\n-// List takes label and field selectors, and returns the list of HorizontalPodAutoscalers that match those selectors.\n-func (c *horizontalPodAutoscalers) List(opts meta_v1.ListOptions) (result *v1.HorizontalPodAutoscalerList, err error) {\n-\tresult = &v1.HorizontalPodAutoscalerList{}\n-\terr = c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"horizontalpodautoscalers\").\n-\t\tVersionedParams(&opts, scheme.ParameterCodec).\n-\t\tDo().\n-\t\tInto(result)\n-\treturn\n-}\n-\n-// Watch returns a watch.Interface that watches the requested horizontalPodAutoscalers.\n-func (c *horizontalPodAutoscalers) Watch(opts meta_v1.ListOptions) (watch.Interface, error) {\n-\topts.Watch = true\n-\treturn c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"horizontalpodautoscalers\").\n-\t\tVersionedParams(&opts, scheme.ParameterCodec).\n-\t\tWatch()\n-}\n-\n // Patch applies the patch and returns the patched horizontalPodAutoscaler.\n func (c *horizontalPodAutoscalers) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.HorizontalPodAutoscaler, err error) {\n \tresult = &v1.HorizontalPodAutoscaler{}"
  },
  {
    "sha": "b2bc5942380da42d576af094b445a16305f9c0b4",
    "filename": "federation/client/clientset_generated/federation_clientset/typed/batch/v1/fake/fake_job.go",
    "status": "modified",
    "additions": 47,
    "deletions": 47,
    "changes": 94,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/batch/v1/fake/fake_job.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/batch/v1/fake/fake_job.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/federation/client/clientset_generated/federation_clientset/typed/batch/v1/fake/fake_job.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -17,8 +17,8 @@ limitations under the License.\n package fake\n \n import (\n-\tv1 \"k8s.io/api/batch/v1\"\n-\tmeta_v1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n+\tbatch_v1 \"k8s.io/api/batch/v1\"\n+\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \tlabels \"k8s.io/apimachinery/pkg/labels\"\n \tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n \ttypes \"k8s.io/apimachinery/pkg/types\"\n@@ -36,95 +36,95 @@ var jobsResource = schema.GroupVersionResource{Group: \"batch\", Version: \"v1\", Re\n \n var jobsKind = schema.GroupVersionKind{Group: \"batch\", Version: \"v1\", Kind: \"Job\"}\n \n-func (c *FakeJobs) Create(job *v1.Job) (result *v1.Job, err error) {\n+func (c *FakeJobs) Get(name string, options v1.GetOptions) (result *batch_v1.Job, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewCreateAction(jobsResource, c.ns, job), &v1.Job{})\n+\t\tInvokes(testing.NewGetAction(jobsResource, c.ns, name), &batch_v1.Job{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.Job), err\n+\treturn obj.(*batch_v1.Job), err\n }\n \n-func (c *FakeJobs) Update(job *v1.Job) (result *v1.Job, err error) {\n+func (c *FakeJobs) List(opts v1.ListOptions) (result *batch_v1.JobList, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewUpdateAction(jobsResource, c.ns, job), &v1.Job{})\n+\t\tInvokes(testing.NewListAction(jobsResource, jobsKind, c.ns, opts), &batch_v1.JobList{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.Job), err\n-}\n-\n-func (c *FakeJobs) UpdateStatus(job *v1.Job) (*v1.Job, error) {\n-\tobj, err := c.Fake.\n-\t\tInvokes(testing.NewUpdateSubresourceAction(jobsResource, \"status\", c.ns, job), &v1.Job{})\n \n-\tif obj == nil {\n-\t\treturn nil, err\n+\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n+\tif label == nil {\n+\t\tlabel = labels.Everything()\n \t}\n-\treturn obj.(*v1.Job), err\n+\tlist := &batch_v1.JobList{}\n+\tfor _, item := range obj.(*batch_v1.JobList).Items {\n+\t\tif label.Matches(labels.Set(item.Labels)) {\n+\t\t\tlist.Items = append(list.Items, item)\n+\t\t}\n+\t}\n+\treturn list, err\n }\n \n-func (c *FakeJobs) Delete(name string, options *meta_v1.DeleteOptions) error {\n-\t_, err := c.Fake.\n-\t\tInvokes(testing.NewDeleteAction(jobsResource, c.ns, name), &v1.Job{})\n+// Watch returns a watch.Interface that watches the requested jobs.\n+func (c *FakeJobs) Watch(opts v1.ListOptions) (watch.Interface, error) {\n+\treturn c.Fake.\n+\t\tInvokesWatch(testing.NewWatchAction(jobsResource, c.ns, opts))\n \n-\treturn err\n }\n \n-func (c *FakeJobs) DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta_v1.ListOptions) error {\n-\taction := testing.NewDeleteCollectionAction(jobsResource, c.ns, listOptions)\n+func (c *FakeJobs) Create(job *batch_v1.Job) (result *batch_v1.Job, err error) {\n+\tobj, err := c.Fake.\n+\t\tInvokes(testing.NewCreateAction(jobsResource, c.ns, job), &batch_v1.Job{})\n \n-\t_, err := c.Fake.Invokes(action, &v1.JobList{})\n-\treturn err\n+\tif obj == nil {\n+\t\treturn nil, err\n+\t}\n+\treturn obj.(*batch_v1.Job), err\n }\n \n-func (c *FakeJobs) Get(name string, options meta_v1.GetOptions) (result *v1.Job, err error) {\n+func (c *FakeJobs) Update(job *batch_v1.Job) (result *batch_v1.Job, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewGetAction(jobsResource, c.ns, name), &v1.Job{})\n+\t\tInvokes(testing.NewUpdateAction(jobsResource, c.ns, job), &batch_v1.Job{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.Job), err\n+\treturn obj.(*batch_v1.Job), err\n }\n \n-func (c *FakeJobs) List(opts meta_v1.ListOptions) (result *v1.JobList, err error) {\n+func (c *FakeJobs) UpdateStatus(job *batch_v1.Job) (*batch_v1.Job, error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewListAction(jobsResource, jobsKind, c.ns, opts), &v1.JobList{})\n+\t\tInvokes(testing.NewUpdateSubresourceAction(jobsResource, \"status\", c.ns, job), &batch_v1.Job{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n+\treturn obj.(*batch_v1.Job), err\n+}\n \n-\tlabel, _, _ := testing.ExtractFromListOptions(opts)\n-\tif label == nil {\n-\t\tlabel = labels.Everything()\n-\t}\n-\tlist := &v1.JobList{}\n-\tfor _, item := range obj.(*v1.JobList).Items {\n-\t\tif label.Matches(labels.Set(item.Labels)) {\n-\t\t\tlist.Items = append(list.Items, item)\n-\t\t}\n-\t}\n-\treturn list, err\n+func (c *FakeJobs) Delete(name string, options *v1.DeleteOptions) error {\n+\t_, err := c.Fake.\n+\t\tInvokes(testing.NewDeleteAction(jobsResource, c.ns, name), &batch_v1.Job{})\n+\n+\treturn err\n }\n \n-// Watch returns a watch.Interface that watches the requested jobs.\n-func (c *FakeJobs) Watch(opts meta_v1.ListOptions) (watch.Interface, error) {\n-\treturn c.Fake.\n-\t\tInvokesWatch(testing.NewWatchAction(jobsResource, c.ns, opts))\n+func (c *FakeJobs) DeleteCollection(options *v1.DeleteOptions, listOptions v1.ListOptions) error {\n+\taction := testing.NewDeleteCollectionAction(jobsResource, c.ns, listOptions)\n \n+\t_, err := c.Fake.Invokes(action, &batch_v1.JobList{})\n+\treturn err\n }\n \n // Patch applies the patch and returns the patched job.\n-func (c *FakeJobs) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.Job, err error) {\n+func (c *FakeJobs) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *batch_v1.Job, err error) {\n \tobj, err := c.Fake.\n-\t\tInvokes(testing.NewPatchSubresourceAction(jobsResource, c.ns, name, data, subresources...), &v1.Job{})\n+\t\tInvokes(testing.NewPatchSubresourceAction(jobsResource, c.ns, name, data, subresources...), &batch_v1.Job{})\n \n \tif obj == nil {\n \t\treturn nil, err\n \t}\n-\treturn obj.(*v1.Job), err\n+\treturn obj.(*batch_v1.Job), err\n }"
  },
  {
    "sha": "74e10550f86d0710b622d06b48cf20fd7991021d",
    "filename": "federation/client/clientset_generated/federation_clientset/typed/batch/v1/job.go",
    "status": "modified",
    "additions": 36,
    "deletions": 36,
    "changes": 72,
    "blob_url": "https://github.com/kubernetes/kubernetes/blob/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/batch/v1/job.go",
    "raw_url": "https://github.com/kubernetes/kubernetes/raw/c131f02b3295890fd4e999be56453949d09be1c1/federation/client/clientset_generated/federation_clientset/typed/batch/v1/job.go",
    "contents_url": "https://api.github.com/repos/kubernetes/kubernetes/contents/federation/client/clientset_generated/federation_clientset/typed/batch/v1/job.go?ref=c131f02b3295890fd4e999be56453949d09be1c1",
    "patch": "@@ -59,6 +59,41 @@ func newJobs(c *BatchV1Client, namespace string) *jobs {\n \t}\n }\n \n+// Get takes name of the job, and returns the corresponding job object, and an error if there is any.\n+func (c *jobs) Get(name string, options meta_v1.GetOptions) (result *v1.Job, err error) {\n+\tresult = &v1.Job{}\n+\terr = c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"jobs\").\n+\t\tName(name).\n+\t\tVersionedParams(&options, scheme.ParameterCodec).\n+\t\tDo().\n+\t\tInto(result)\n+\treturn\n+}\n+\n+// List takes label and field selectors, and returns the list of Jobs that match those selectors.\n+func (c *jobs) List(opts meta_v1.ListOptions) (result *v1.JobList, err error) {\n+\tresult = &v1.JobList{}\n+\terr = c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"jobs\").\n+\t\tVersionedParams(&opts, scheme.ParameterCodec).\n+\t\tDo().\n+\t\tInto(result)\n+\treturn\n+}\n+\n+// Watch returns a watch.Interface that watches the requested jobs.\n+func (c *jobs) Watch(opts meta_v1.ListOptions) (watch.Interface, error) {\n+\topts.Watch = true\n+\treturn c.client.Get().\n+\t\tNamespace(c.ns).\n+\t\tResource(\"jobs\").\n+\t\tVersionedParams(&opts, scheme.ParameterCodec).\n+\t\tWatch()\n+}\n+\n // Create takes the representation of a job and creates it.  Returns the server's representation of the job, and an error, if there is any.\n func (c *jobs) Create(job *v1.Job) (result *v1.Job, err error) {\n \tresult = &v1.Job{}\n@@ -85,7 +120,7 @@ func (c *jobs) Update(job *v1.Job) (result *v1.Job, err error) {\n }\n \n // UpdateStatus was generated because the type contains a Status member.\n-// Add a +genclientstatus=false comment above the type to avoid generating UpdateStatus().\n+// Add a +genclient:noStatus comment above the type to avoid generating UpdateStatus().\n \n func (c *jobs) UpdateStatus(job *v1.Job) (result *v1.Job, err error) {\n \tresult = &v1.Job{}\n@@ -122,41 +157,6 @@ func (c *jobs) DeleteCollection(options *meta_v1.DeleteOptions, listOptions meta\n \t\tError()\n }\n \n-// Get takes name of the job, and returns the corresponding job object, and an error if there is any.\n-func (c *jobs) Get(name string, options meta_v1.GetOptions) (result *v1.Job, err error) {\n-\tresult = &v1.Job{}\n-\terr = c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"jobs\").\n-\t\tName(name).\n-\t\tVersionedParams(&options, scheme.ParameterCodec).\n-\t\tDo().\n-\t\tInto(result)\n-\treturn\n-}\n-\n-// List takes label and field selectors, and returns the list of Jobs that match those selectors.\n-func (c *jobs) List(opts meta_v1.ListOptions) (result *v1.JobList, err error) {\n-\tresult = &v1.JobList{}\n-\terr = c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"jobs\").\n-\t\tVersionedParams(&opts, scheme.ParameterCodec).\n-\t\tDo().\n-\t\tInto(result)\n-\treturn\n-}\n-\n-// Watch returns a watch.Interface that watches the requested jobs.\n-func (c *jobs) Watch(opts meta_v1.ListOptions) (watch.Interface, error) {\n-\topts.Watch = true\n-\treturn c.client.Get().\n-\t\tNamespace(c.ns).\n-\t\tResource(\"jobs\").\n-\t\tVersionedParams(&opts, scheme.ParameterCodec).\n-\t\tWatch()\n-}\n-\n // Patch applies the patch and returns the patched job.\n func (c *jobs) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1.Job, err error) {\n \tresult = &v1.Job{}"
  }
]
